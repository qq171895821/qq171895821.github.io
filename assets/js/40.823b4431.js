(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{629:function(t,s,a){"use strict";a.r(s);var r=a(0),v=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",[t._v("来看看栈和队列不为人知的一面")])]),t._v(" "),a("p",[t._v("我想栈和队列的原理大家应该很熟悉了，队列总是先进先出，栈是先进后出。")]),t._v(" "),a("p",[t._v("如图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/qq171895821/Jymscloudiimmgg@main/img/zhd1.png",alt:""}})]),t._v(" "),a("p",[t._v("那么我再这里列出四个关于栈的问题，大家可以思考一下，以下是以C++为例，相信使用其他编程语言的同学也对应思考以下，自己使用的编程语言里栈和队列是什么样的。")]),t._v(" "),a("ol",[a("li",[t._v("C++中stack是容器么？")]),t._v(" "),a("li",[t._v("我们使用的stack是属于哪个版本的STL？")]),t._v(" "),a("li",[t._v("我们使用的STL中stack是如何实现的？")]),t._v(" "),a("li",[t._v("stack提供迭代器来遍历stack空间么？")])]),t._v(" "),a("p",[t._v("相信这四个问题并不那么好回答，因为一些同学使用数据结构会停留在非常表面的应用上，稍稍往深一问，就会有好像懂，好像也不懂的感觉。")]),t._v(" "),a("p",[t._v("有的同学可能仅仅知道栈和队列这么个数据结构，却不知道底层实现，也不清楚所使用的栈和队列和STL是什么关系。")]),t._v(" "),a("p",[t._v("所以这里我给大家扫一遍基础知识，")]),t._v(" "),a("p",[t._v("首先大家要知道栈和队列是STL（C++标准库）里面的两个数据结构。")]),t._v(" "),a("p",[t._v("C++标准库是由多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。")]),t._v(" "),a("ol",[a("li",[t._v("HP STL")])]),t._v(" "),a("p",[t._v("其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++STL的第一个实现版本，而且开放源代码")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("P.J.Plauger STL")])]),t._v(" "),a("p",[t._v("由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("SGI STL")])]),t._v(" "),a("p",[t._v("由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。")]),t._v(" "),a("p",[t._v("接下来介绍的栈和队列也是SGI STL里面的数据结构，"),a("strong",[t._v("我们一般使用的STL也是SGI STL")]),t._v("，知道了使用版本，才知道对应的底层实现。")]),t._v(" "),a("p",[t._v("来说一说栈，栈先进后出，如图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/qq171895821/Jymscloudiimmgg@main/img/zhd2.png",alt:""}})]),t._v(" "),a("p",[t._v("栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。不像是set 或者map 提供迭代器iterator来遍历所有元素。")]),t._v(" "),a("p",[a("strong",[t._v("「栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。」")])]),t._v(" "),a("p",[t._v("所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。")]),t._v(" "),a("p",[t._v("那么问题来了，STL 中栈是用什么容器实现的？")]),t._v(" "),a("p",[t._v("从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/qq171895821/Jymscloudiimmgg@main/img/zhd3.png",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("「我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。」")])]),t._v(" "),a("p",[t._v("deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。")]),t._v(" "),a("p",[a("strong",[t._v("「SGI STL中 队列底层实现缺省情况下一样使用deque实现的。」")])]),t._v(" "),a("p",[t._v("我们也可以指定vector为栈的底层实现，初始化语句如下：")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("vector"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" third"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用vector为底层容器的栈")]),t._v("\n")])])]),a("p",[t._v("刚刚讲过栈的特性，对应的队列的情况是一样的。")]),t._v(" "),a("p",[t._v("队列 先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, "),a("strong",[t._v("SGI STL中队列一样是以deque为缺省情况下的底部结构。")])]),t._v(" "),a("p",[t._v("也可以指定list 为起底层实现，初始化queue的语句如下：")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("queue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" third"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义以list为底层容器的队列")]),t._v("\n")])])]),a("p",[t._v("所以STL中队列也不被归类为容器，而被归类为container adapter（ 容器适配器）")]),t._v(" "),a("p",[t._v("我这里讲的都是（clck）C++ 语言中情况， 使用其他语言的同学也要思考栈与队列的底层实现问题， 不要对数据结构的使用浅尝辄止，而要深挖起内部原理，才能夯实基础！")])])}),[],!1,null,null,null);s.default=v.exports}}]);