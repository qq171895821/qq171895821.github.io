(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{604:function(t,a,s){"use strict";s.r(a);var e=s(0),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",[t._v("SVG中Path元素的学习记录")])]),t._v(" "),s("p",[s("code",[t._v("<path>")]),t._v("是SVG基本形状中最强大的一个。你可以用它创建线条、曲线、弧形等等。")]),t._v(" "),s("p",[t._v("path只需要设置很少的点，就可以创建平滑流畅的线条（比如曲线）")]),t._v(" "),s("p",[t._v("path元素的形状是通过属性d定义的，属性d的值是一个“命令+参数”的序列。每一个命令都用一个关键字母来表示，比如字母"),s("code",[t._v("M")]),t._v("表示的是"),s("code",[t._v("Move to")]),t._v("命令，当解析器读到这个命令时，他就知道你打算移动到某个点。跟在命令字母后面的，是你需要移动到的那个点的X和Y轴坐标。比如移动到（10，10）这个点的命令，应该写成"),s("code",[t._v("M“10 10”")]),t._v(".这一段字符结束后，解析器就回去读下一段命令。每一个命令都有两种表示方式，一种是用"),s("strong",[t._v("大写字母")]),t._v("，表示采用绝对定位。另一种是用"),s("strong",[t._v("小写字母")]),t._v("，表示采用相对定位（例如，从上一个点开始，向上移动10px， 向左移动7px）。")]),t._v(" "),s("p",[t._v("因为属性d采用的是用户坐标系统，所以"),s("strong",[t._v("不需要表明单位")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"直线命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#直线命令"}},[t._v("#")]),t._v(" 直线命令")]),t._v(" "),s("p",[s("code",[t._v("<path>")]),t._v("元素里又5个画直线的命令，顾名思义，直线命令就是在两个点之间画直线。首先是“Move to”命令，M，它需要两个参数，分别是需要移动到的点的X轴和Y轴坐标。假设，你的画笔当前位于一个点，在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。因为M命令仅仅是移动画笔，但不画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("M x y")])]),t._v(" "),s("p",[t._v("或")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("m dx dy")])]),t._v(" "),s("p",[t._v("能够真正画出线的命令有三个（M命令是移动画笔位置，但是不画线），最常用的是“Line to”命令，"),s("code",[t._v("L")]),t._v("，"),s("code",[t._v("L")]),t._v("需要两个参数，分别是一个点的x轴和y轴坐标，L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("L x y (or l dx dy)")])]),t._v(" "),s("p",[t._v("另外还有两个简写命令，用来绘制水平线和垂直线。"),s("code",[t._v("H")]),t._v("，绘制水平线。"),s("code",[t._v("V")]),t._v("，绘制垂直线。这两个命令都只带一个参数，标明在x轴或y轴移动到的位置，因为它们都只在坐标轴的一个方向上移动。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("H x (or h dx)")]),t._v(" "),s("p",[t._v("V y (or v dy)")])]),t._v(" "),s("p",[t._v("最后，我们可以通过一个“闭合路径命令”Z来简化上面的path，"),s("code",[t._v("Z")]),t._v("命令会从当前点画一条直线到路径的起点，尽管我们不总是需要闭合路径，但是它还是经常被放到路径的最后。另外，Z命令不用区分大小写。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("Z (or z)")])]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[t._v(" "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("path")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("d")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("M10 10 h 80 v 80 h -80 Z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("fill")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("transparent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("stroke")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("black"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])]),s("p",[t._v("上述路径是：画笔移动到(10,10)点，由此开始，向右移动80像素构成一条水平线，然后向下移动80像素，然后向左移动80像素，然后再回到起点。")]),t._v(" "),s("p",[t._v("你可能会问这些命令有什么用，因为 "),s("code",[t._v("<polygon>")]),t._v(" 和 "),s("code",[t._v("<polyline>")]),t._v(" 可以做到画出一样的图形。答案是，这些命令可以做得更多。如果你只是画直线，那么其他元素可能会更好用，但是，path却是众多开发者在SVG绘制中经常用到的。据我所知，它们之间不存在性能上的优劣。但是通过脚本生成path可能有所不同，因为另外两种方法只需要指明点，而path在这方面的语法会更复杂一些。")]),t._v(" "),s("h2",{attrs:{id:"曲线命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#曲线命令"}},[t._v("#")]),t._v(" 曲线命令")]),t._v(" "),s("h3",{attrs:{id:"贝塞尔曲线"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贝塞尔曲线"}},[t._v("#")]),t._v(" 贝塞尔曲线")]),t._v(" "),s("p",[t._v("在path元素里，只存在两种贝塞尔曲线：三次贝塞尔曲线C，和二次贝塞尔曲线Q。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\n")])])]),s("p",[t._v("这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。（文字描述不好，维基百科上有图示，更直观。）")]),t._v(" "),s("p",[t._v("你可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，你可以使用一个简写的贝塞尔曲线命令S，如下所示：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" S x2 y2, x y (or s dx2 dy2, dx dy)\n")])])]),s("p",[t._v("S命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。")]),t._v(" "),s("p",[t._v("另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" Q x1 y1, x y (or q dx1 dy1, dx dy)\n")])])]),s("p",[t._v("就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" T x y (or t dx dy)\n")])])]),s("p",[t._v("和之前一样，快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。")]),t._v(" "),s("p",[t._v("虽然三次贝塞尔曲线拥有更大的自由度，但是两种曲线能达到的效果总是差不多的。具体使用哪种曲线，通常取决于需求，以及对曲线对称性的依赖程度。")]),t._v(" "),s("h2",{attrs:{id:"弧形"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#弧形"}},[t._v("#")]),t._v(" 弧形")]),t._v(" "),s("p",[t._v("弧形命令A是另一个创建SVG曲线的命令。基本上，弧形可以视为圆形或椭圆形的一部分。假设，已知椭圆形的长轴半径和短轴半径，并且已知两个点（在椭圆上），根据半径和两点，可以画出两个椭圆，在每个椭圆上根据两点都可以画出两种弧形。所以，仅仅根据半径和两点，可以画出四种弧形。为了保证创建的弧形唯一，A命令需要用到比较多的参数：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n")])])]),s("p",[t._v("弧形命令A的前两个参数分别是x轴半径和y轴半径，它们的作用很明显，不用多做解释，如果你不是很清楚它们的作用，可以参考一下椭圆"),s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/ellipse",target:"_blank",rel:"noopener noreferrer"}},[t._v("ellipse"),s("OutboundLink")],1),t._v("命令中的相同参数。弧形命令A的第三个参数表示弧形的旋转情况")])])}),[],!1,null,null,null);a.default=v.exports}}]);